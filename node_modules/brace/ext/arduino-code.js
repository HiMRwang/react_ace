import bindAll from 'lodash.bindall';
import PropTypes from 'prop-types';
import React from 'react';
import ArduinoCodeComponent from '../../components/arduino/arduino-code/arduino-code.jsx';
import {
    connect
} from 'react-redux';

import {
    injectIntl
} from 'react-intl';
import {
    setHoveredCode
} from "../../reducers/hoveredCode";
import {
    ExtensionLanguageState,
    ExtensionBoardState,
    BoardMicrobit,
    LanguageCpp,
    LanguageMicropython
} from "../../reducers/board-and-language-state";
import VM from 'scratch-vm';
import VMScratchBlocks from '../../lib/arduino-blocks.js';
import Blockly from 'arduino-blocks';
import {
    setArduinoWriteCode
} from "../../reducers/arduinoTab-code";
import {
    setAceCodeStyle
} from "../../reducers/arduino-ace-style";
import {
    toAddCode,
    lengthChange
} from '../../reducers/drag-code';
import {
    codeAceFontNumber
} from '../../reducers/arduino-size';
import regNumber from '../../lib/regNumber.js';
import Arduino from '../../lib/block-generator/Arduino/index';
import MicroPython from '../../lib/block-generator/MicroPython/index';
import cppPrompt from '../../lib/write-prompt/cpp-code';
import microPythonPrompt from '../../lib/write-prompt/micropython-code';
import tools from 'brace/ext/language_tools';
import dfrobotAlert from '../../lib/custom-dialog/custom-dialog';
import maxResetCode from '../../lib/maxResetCode';

class ArduinoCode extends React.Component {
    constructor(props) {
        super(props);
        bindAll(this, [
            'handleMouseEnter',
            'handleMouseLeave',
            'handleBlockDragEnd',
            'handleChangeCode',
            'handleCopyCode',
            'handleCutCode',
            'handlePasteCode',
            'handleSelectAllCode',
            'handleRedoCode',
            'handleUndoCode',
            'codeRef',
            'handleChangeTheme',
            'handleMouseMove',
            'handleChangeCodePrompt',
            'handleClearCache',
            'handleScrollMouse',
            'handleMaxReset'
        ]);
        this.x = 0;
        this.y = 0;
        this.hoveredCode = false;
        this.oldLanguage = '';
    }
    componentDidMount() {
        this.props.vm.addListener('BLOCK_DRAG_END', this.handleBlockDragEnd);
        document.addEventListener('mousemove', this.handleMouseMove);
    }
    componentWillUnmount() {
        if (this.cRef.editor.completers) {
            this.cRef.editor.completers.splice(3, 1);
        }
        this.props.vm.removeListener('BLOCK_DRAG_END', this.handleBlockDragEnd);
        document.removeEventListener('mousemove', this.handleMouseMove);

    }
    handleScrollMouse(e) {
        if (e.wheelDelta && e.ctrlKey) { //IE/Opera/Chrome
            if (e.wheelDelta === 120) {
                this.props.setFontNumber(this.props.fontNumber + 1);
            } else if (e.wheelDelta === -120) {
                this.props.setFontNumber(this.props.fontNumber - 1);
            }
        }
    }
    handleChangeCodePrompt(language) {
        if (!this.props.isWrite || this.oldLanguage === language) return;
        try {
            if (this.props.language === LanguageMicropython) {
                if (this.cRef && this.cRef.editor.completers) {
                    console.log(this.cRef.editor.completers);
                    if (this.cRef.editor.completers.length === 3) {
                        tools.addCompleter(microPythonPrompt);
                    } else {
                        const num = this.cRef.editor.completers.length - 3;
                        this.cRef.editor.completers.splice(3, num, microPythonPrompt);
                    }
                } else {
                    tools.addCompleter(microPythonPrompt);
                }
            } else {
                if (this.cRef && this.cRef.editor.completers) {
                    console.log(this.cRef.editor.completers);
                    if (this.cRef.editor.completers.length === 3) {
                        tools.addCompleter(cppPrompt);
                    } else {
                        const num = this.cRef.editor.completers.length - 3;
                        this.cRef.editor.completers.splice(3, num, cppPrompt);
                    }
                } else {
                    tools.addCompleter(cppPrompt);
                }
            }
            this.oldLanguage = language;
        } catch (e) {
            console.log(e);
        }
    }
    handleMouseMove(e) {
        //加上preventDefault会导致不能拖动选中文字
        // e.preventDefault();
        this.x = e.pageX;
        // 预料之外的偏差，减去60px,有bug,无法显示在最下面
        this.y = e.pageY - 60;
    }
    handleMouseEnter() {
        this.props.dispatchSetHoveredCode(true);
        this.hoveredCode = true;
        document.addEventListener('mousewheel', this.handleScrollMouse, false);
    }
    handleMouseLeave() {
        this.props.dispatchSetHoveredCode(false);
        this.hoveredCode = false;
        document.removeEventListener('mousewheel', this.handleScrollMouse);
    }
    handleChangeCode(code) {
        this.props.setArduinoWriteCode(code, false);
        localStorage.setItem('writeCode', code);
    }
    handleBlockDragEnd(blocks) {
        // 创建管理blocks的类
        if (this.props.isWrite) {
            const newBlocksManage = this.props.vm.runtime._getANewBlocks();
            for (let i = 0; i < blocks.length; i++) {
                // 将blocks添加到类中
                newBlocksManage.createBlock(blocks[i]);
            }
            // 获取blocks的首项
            const topId = newBlocksManage.getTopLevelScript(blocks[0].id);
            // 获取blocks的xml
            let xml = newBlocksManage.blockToXML(topId);
            xml = '<xml xmlns="http://www.w3.org/1999/xhtml ">' + xml + '</xml>';
            // xml包装成dom
            const dom = Blockly.Xml.textToDom(xml);
            // console.log('dom------:',xml,dom);
            // 创建div用于放置workspace
            const codeInjectDiv = document.createElement('div');
            // console.log('cideUbhectDuv',codeInjectDiv);
            codeInjectDiv.setAttribute('id', 'codeInjectDiv');
            codeInjectDiv.style.display = 'none';
            document.body.appendChild(codeInjectDiv);
            const workspace = VMScratchBlocks(this.props.vm, this.props.intl).inject(codeInjectDiv);
            // 将dom加入到workspace中
            Blockly.Xml.domToWorkspace(dom, workspace);
            // console.log('workspace----:',workspace);
            // console.log('workspaceBlocks:',workspace.getTopBlocks(true));
            // 将workspace编译成代码
            let language, code;
            if (this.props.language === LanguageCpp) {
                language = 'Arduino';
                code = Arduino.workspaceToCode(workspace, true);
            } else if (this.props.language === LanguageMicropython) {
                language = 'MicroPython';
                code = MicroPython.workspaceToCode(workspace, true);
            } else {
                language = 'Arduino';
                code = Arduino.workspaceToCode(workspace, true);
            }
            // 删除div
            document.body.removeChild(document.getElementById('codeInjectDiv'));
            // 将代码加入到
            // const id = new Date().getTime();
            // document.onblur = null;
            const newCode = {
                code: code[1],
                x: this.x || 600,
                y: this.y || 600,
                visible: true
            };
            this.props.setNewCode(newCode);
            this.props.setLengthChange(true);
            this.props.setLengthChange(false);
            // this.props.setArduinoWriteCode(code[1], true);
        }
    }
    handleCopyCode(e) {
        // 复制代码到剪切板
        e.preventDefault();
        document.execCommand('Copy');
    }
    handleCutCode(e) {
        // 剪切代码到剪切板
        e.preventDefault();
        document.execCommand('Cut');
    }
    handlePasteCode(e) {
        // 粘贴代码到剪切板
        e.preventDefault();
        document.execCommand('Paste');
    }
    handleSelectAllCode(e) {
        e.preventDefault();
        document.execCommand('SelectAll');
        this.cRef.editor.selectAll();
    }
    handleRedoCode(e) {
        e.preventDefault();
        this.cRef.editor.redo();
    }
    handleUndoCode(e) {
        e.preventDefault();
        this.cRef.editor.undo();
    }
    handleChangeTheme(e) {
        const newStyle = e.target.value;
        this.props.setAceCodeStyle(newStyle);
    }
    handleClearCache(e) {
        this.cRef.editor.session.getUndoManager().reset();
    }
    codeRef(ref) {
        this.cRef = ref;
    }
    handleMaxReset() {
        const callback = () => {
            this.props.setArduinoWriteCode(maxResetCode, false);
        }
        dfrobotAlert('提示', '是否删除编辑区代码并加载出厂设置代码', {
            cover: true,
            btns: [{
                text: '是',
                callBack: callback
            }, {
                text: '否'
            }]
        });

    }
    render() {
        const {
            blockCode,
            arduinoCodeProps,
            writeCode,
            dispatchSetHoveredCode,
            vm,
            hoveredCode,
            setAceCodeStyle,
            setNewCode,
            setFontNumber,
            setLengthChange,
            ...props
        } = this.props;
        this.handleChangeCodePrompt(this.props.language);
        return (
            <ArduinoCodeComponent
                code={this.props.isWrite ? writeCode : blockCode}
               
                codeRef={this.codeRef}
                onChangeCode={this.handleChangeCode}
                onChangeCodeStyle={this.handleChangeTheme}
                onClearCache={this.handleClearCache}
                onCopyCode={this.handleCopyCode}
                onCutCode={this.handleCutCode}
                onMaxReset={this.handleMaxReset}
                onMouseEnter={this.handleMouseEnter}
                onMouseLeave={this.handleMouseLeave}
                onPasteCode={this.handlePasteCode}
                onRedoCode={this.handleRedoCode}
                onSelectAllCode={this.handleSelectAllCode}
                onUndoCode={this.handleUndoCode}
                {...props}
            />
        );
    }
}

ArduinoCode.propTypes = {
    blockCode: PropTypes.string,
    codeStyle: PropTypes.string,
    dispatchSetHoveredCode: PropTypes.func,
    fontNumber: PropTypes.number,
    height: PropTypes.string,
    isWrite: PropTypes.bool,
    language: PropTypes.string,
    setAceCodeStyle: PropTypes.func,
    setNewCode: PropTypes.func,
    theme: PropTypes.string,
    vm: PropTypes.instanceOf(VM),
    width: PropTypes.string,
    writeCode: PropTypes.string,
};

const mapStateToProps = state => ({
    blockCode: state.arduinoTabCode.arduinoBlockCode,
    codeStyle: state.arduinoAceStyle.codeStyle,
    isDisable: state.boardAndLanguageState[ExtensionBoardState] === BoardMicrobit,
    isWrite: state.arduinoCodeIsWrite.isWrite,
    writeCode: state.arduinoTabCode.arduinoWriteCode,
    width: regNumber(state.arduinoSize.width) < 20 ? '0px' : (regNumber(state.arduinoSize.width) - 20).toString().concat('px'),
    height: regNumber(state.arduinoSize.codeHeight) < 20 ? '0px' : (regNumber(state.arduinoSize.codeHeight) - 20).toString().concat('px'),
    hoveredCode: state.hoveredCode.code,
    fontNumber: state.arduinoSize.fontNumber,
    language: state.boardAndLanguageState[ExtensionLanguageState]
});

const mapDispatchToProps = dispatch => ({
    dispatchSetHoveredCode: isInCode => {
        dispatch(setHoveredCode(isInCode));
    },
    setArduinoWriteCode: (code, isAdd) => {
        dispatch(setArduinoWriteCode(code, isAdd));
    },
    setAceCodeStyle: style => {
        dispatch(setAceCodeStyle(style));
    },
    setNewCode: code => {
        dispatch(toAddCode(code));
    },
    setLengthChange: boo => {
        dispatch(lengthChange(boo));
    },
    setFontNumber: num => {
        dispatch(codeAceFontNumber(num))
    }
});

export default injectIntl(connect(mapStateToProps, mapDispatchToProps)(ArduinoCode));